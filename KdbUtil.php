<?php
/**
 * @author Lutz-Peter Hooge
 * @license http://www.gnu.org/licenses/lgpl-3.0.txt GNU LESSER GENERAL PUBLIC LICENSE
 * @package libKeePHPass
*/
class KdbUtil{
	
	/**
	 * converts a binary kdb-date to unix timestamp
	 * 
	 * @param string $bintime
	 * @return int
	 */
	public static function unpackTime($bintime){
		if(strlen($bintime) < 5){
			throw new Exception("invalid binary time value: ".BinStr::toHex($bintime));
		}
		
		$dw1 = ord($bintime{0});
		$dw2 = ord($bintime{1});
		$dw3 = ord($bintime{2});
		$dw4 = ord($bintime{3});
		$dw5 = ord($bintime{4});
		
		$year = ($dw1 << 6) | ($dw2 >> 2);
		$month = (($dw2 & 0x03) << 2) | ($dw3 >> 6);
		$day = ($dw3 >> 1) & 0x1F;
		$hour = (($dw3 & 0x01) << 4) | ($dw4 >> 4);
		$minute = (($dw4 & 0x0F) << 2) | ($dw5 >> 6);
		$second = $dw5 & 0x03F;
		
		$ts = mktime($hour,$minute,$second,$month,$day,$year);
		return $ts;
	}
	
	/**
	 * converts a unix timestamp to binary kdb-date
	 * 
	 * @param int $time
	 * @return string
	 */
	public static function packTime($time){
		$year = (int) date('Y', $time);
		$month = (int) date('m', $time);
		$day = (int) date('d', $time);
		$hour = (int) date('H', $time);
		$minute = (int) date('i', $time);
		$second = (int) date('s', $time);

		$bytes = str_repeat("\0", 5);
		$bytes{0} = chr(($year >> 6) & 0x3F);
		$bytes{1} = chr((($year & 0x3F) << 2) | (($month >> 2) & 0x03));
		$bytes{2} = chr((($month & 0x03) << 6) | (($day & 0x1F) << 1) | (($hour >> 4) & 0x01));
		$bytes{3} = chr((($hour & 0x0F) << 4) | (($minute >> 2) & 0x0F));
		$bytes{4} = chr((($minute & 0x03) << 6) | ($second & 0x3F));
	
		return $bytes;
	}
	
	/**
	 * decodes and validates hashed block stream, returns clean stream
	 * 
	 * @param BinStr $input
	 * @param BinStr $output
	 * @param bool $validate
	 * @return BinStr
	 */
	public static function stripHashedBlocks(BinStr $input, BinStr $output = null, $validate=true){
		if(!$output){
			$output = new BinStr(new StringStream());
		}
		$buffer_index = 0;
		while(!$input->eof()){
			if($input->readUnsignedLong() !== $buffer_index){
				throw new Exception("invalid data, unexpected block index");
			}
			$buffer_index++;
			$stored_hash = $input->read(32);
			$buffer_size = $input->readUnsignedLong();
			
			if($buffer_size){
				$data = $input->read($buffer_size);
				$hash = hash('sha256', $data, true);
			} else {
				$data = '';
				$hash = str_repeat("\0", 32);
			}
			
			// verify
			if($validate AND $hash !== $stored_hash){
				throw new Exception("invalid data, hash mismatch");
			}
			$output->write($data);
		}
		return $output;
	}
	
	/**
	 * encodes input stream with hashed blocks to output stream
	 * 
	 * @param BinStr $input
	 * @param BinStr $output
	 * @param int blocksize default 1MB
	 * @return BinStr
	 */
	public static function writeHashedBlocks(BinStr $input, BinStr $output = null, $block_size=1048576){
		if(!$output){
			$output = new BinStr(new StringStream());
		}
		$buffer_index = 0;
		while(true){
			$remaining = $input->remaining();
			$buffer_size = min($block_size, $remaining);
			$data = $input->read($buffer_size);
			$hash = $buffer_size>0?hash('sha256', $data, true):str_repeat("\0",32);
			
			$output->write(BinStr::fromInt($buffer_index,4));
			$output->write($hash);
			$output->write(BinStr::fromInt($buffer_size,4));
			$output->write($data);
			
			$buffer_index++;
			if($remaining == 0){
				break;
			}
		}
		return $output;
	}
	
	/**
	 * This is a wrapper for gzip/zlib decode function.
	 * This is different from 'inflate' and 'uncompress', so a workaround is needed since the php zlib extension doesn't expose this function directly
	 * 
	 * @param string $encoded
	 * @return string
	 */
	public static function gzdecode($encoded){
		if (function_exists('gzdecode')){
			return gzdecode($encoded);
		} else {
			return file_get_contents('compress.zlib://data:text/xml;base64,'. base64_encode($encoded));
		}
	}
	
	public static function gzencode($plain){
		return gzencode($plain);
	}
	
	/**
	 * loads key from a keyfile, either xml or plain
	 * 
	 * @param string $filename
	 * @return string
	 */
	public static function getKeyfileKey($filename){
		if(!file_exists($filename)){
			throw new Exception("keyfile $filename does not exist");
		}
		if(filesize($filename) == 64){ // this is probably a keepass 1.x generated file, containing a hex encoded key
			$data = file_get_contents($filename);
			$data = BinStr::fromHex($data);
			if(strlen($data) == 32){
				return $data;
			}
		}
		if(class_exists('DOMDocument')){ // try to load xml keyfile generated by keepass 2.x
			$dom = new DOMDocument();
			@$dom->load($filename);
			$xp = new DOMXPath($dom);
			$data = $xp->evaluate('string(//KeyFile/Key/Data)');
			if(is_string($data)){
				$data = base64_decode($data);
				if($data){
					return $data;
				}
			}
		}
		return hash_file('sha256', $filename, true); // plain keyfile, return sha256 digest of it
	}
}